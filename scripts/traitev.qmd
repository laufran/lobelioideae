---
title: "inferring trait evolution on subnetworks"
output: github_document
date: 2025-7-9
---

```{julia}
using CSV, DataFrames, PhyloNetworks
using PhyloPlots, RCall, PhyloTraits
using StatsBase
include("snaq_setup.jl");
```

# Estimate transition rates for each subclade

## Set up `@everywhere` block with trait dataframes, correct hvals
```{julia}
#make trait dfs by filtering down to only cols needed
pollinator_df = select(samples, [:simplename, :pollinator])
fruit_df = select(samples, [:simplename, :fruit])

#rename simplename col to species
#(can't change it in samples df because there already exists a species col)
rename!(pollinator_df, :simplename => :species);
rename!(fruit_df, :simplename => :species);

#rename fruit, pollinator to "trait" to be compatible with fitdiscrete
rename!(fruit_df, :fruit => :trait);
rename!(pollinator_df, :pollinator => :trait);
nosicklebill_df = deepcopy(pollinator_df)
nosicklebill_df.trait = replace.(pollinator_df.trait, "sicklebill" => "hummingbird")

nets_to_hvals_smilax = Dict("actinothrix" => 1, 
                        "andinus" => 1, 
                        "brevilimbatid" => 0,
                        "correoides_nobilis" => 0,
                        "eucentropogonid" => 1,
                        "giganteus_burmeisterid" => 0,
                        "odontosepalus_colombianid" => 2,
                        "peruvianid" => 0,
                        "tupaeformis" => 1,
                        "umbellatus" => 1)
```


## Load in supertree calibrated network estimate transition rates
```{julia}
supertree = readnewick("output/snaq-withoutsmilax/supernet.tre")

filtered_samples = subset(samples, :simplename => ByRow(in(tiplabels(supertree))))
filtered_nosicklebill = subset(nosicklebill_df, :species => ByRow(in(tiplabels(supertree))))
filtered_fruit = subset(fruit_df, :species => ByRow(in(tiplabels(supertree))))
species = filtered_samples.simplename

s1_poll = fitdiscrete(supertree, :ERSM, species, select(filtered_nosicklebill, :trait); optimizeQ=true)
s2_poll = fitdiscrete(supertree, :BTSM, species, select(filtered_nosicklebill, :trait); optimizeQ=true)
s1_fruit = fitdiscrete(supertree, :ERSM, species, select(filtered_fruit, :trait); optimizeQ=true)
s2_fruit = fitdiscrete(supertree, :BTSM, species, select(filtered_fruit, :trait); optimizeQ=true)
```

compare AIC of each model:
```{julia}
aic(s1_poll) #92.26033338520169 --> much better!
aic(s2_poll) #233.5170854022659
aic(s1_fruit) #56.38313045514319 --> much better!
aic(s2_fruit) #105.43158109464444
```

we want the model with the lowest AIC --> in this case both s1 (ERSM) models were best.

julia> s1_poll
PhyloTraits.StatisticalSubstitutionModel:
Equal Rates Substitution Model with k=2,
  all rates equal to α=1.68814.
  rate matrix Q:
       hummingbird     bat
  hummingbird       *  1.6881
       bat  1.6881       *
on a network with 7 reticulations
data:
  91 species
  1 trait
log-likelihood: -45.13017

julia> s1_fruit
PhyloTraits.StatisticalSubstitutionModel:
Equal Rates Substitution Model with k=2,
  all rates equal to α=0.64125.
  rate matrix Q:
           capsule   berry
   capsule       *  0.6413
     berry  0.6413       *
on a network with 7 reticulations
data:
  91 species
  1 trait
log-likelihood: -27.19157

```{julia}
s1_poll_rate = s1_poll.model.rate[1]
s1_fruit_rate = s1_fruit.model.rate[1]
```

# Fit rates to subclades with trait variation
```{julia}
traits_to_clades = Dict("fruit" => ["giganteus_burmeisterid", "odontosepalus_colombianid"], 
                        "pollinator" => ["actinothrix", "andinus", "correoides_nobilis", "giganteus_burmeisterid",
                                        "peruvianid", "tupaeformis", "umbellatus"])

m_fruit = BinaryTraitSubstitutionModel([s1_fruit_rate, s1_fruit_rate], ["berry", "capsule"]);
m_poll = BinaryTraitSubstitutionModel([s1_poll_rate, s1_poll_rate], ["hummingbird", "bat"]);

#initialize dicts to store results in
clade_calibrated = Dict{String, HybridNetwork}()
asr_results = Dict{String, Any}()

for (trait,cladelist) in traits_to_clades
    for clade in cladelist
        if trait == "fruit"
            asrmodel = m_fruit
            trait_df = filtered_fruit
        elseif trait == "pollinator"
            asrmodel = m_poll
            trait_df = filtered_nosicklebill
        end
    

        if clade == "brevilimbatid"
            continue #has no trait variation
        elseif clade == "odontosepalus_colombianid"
            filename = "output/snaq-withsmilax/" * clade * "_calibratednet.tre"
        else
            if nets_to_hvals_smilax[clade] == 0
                filename = "output/snaq-withoutsmilax/" * clade * "_calibratedtree.tre"
            else
                filename = "output/snaq-withoutsmilax/" * clade * "_calibratednet.tre"
            end
        end

        cladetree = readnewick(filename)
        #prune out outgroup
        deleteleaf!(cladetree, "Lysipomia_pumila")
        clade_calibrated[clade] = cladetree

        trait_df = subset(trait_df, :species => ByRow(in(tiplabels(cladetree))))
        species = trait_df.species
        subclade_model_fit = fitdiscrete(cladetree, asrmodel, species, select(trait_df, :trait))
        asr_result  = ancestralreconstruction(subclade_model_fit)
        key = string(clade, "_", trait, "_asr")
        asr_results[key] = asr_result
    end
end
```

# Visualize results per subclade

```{julia}
function plot_discreteasr(asr::DataFrame, figure_filename::AbstractString, net::HybridNetwork, trait::AbstractString)
    asr_dc = deepcopy(asr)
    net_dc =  deepcopy(net)
    PhyloNetworks.resetnodenumbers!(net_dc)
    colnames = names(asr_dc)[3:end] # to get the correct state - probability match
    # create a new column in the asr data frame, filled with the empty string ""
    asr_dc[!,:fake] .= ""; # to add fake internal node labels later: and extract their positions

    #note: I rotate each node number twice
    #I tested doing it once, for some reason did not work.
    #why doing it twice works? I do not know!
    if clade == "tupaeformis"
        for _ in 1:2; for n in [19, 20, 21, 22]; rotate!(net_dc, n); end; end
    elseif clade == "actinothrix"
        rotate!(net_dc, 9); rotate!(net_dc, 9)
    elseif clade == "andinus"
        for _ in 1:2; for n in [12, 13, 16]; rotate!(net_dc, n); end; end
    elseif clade == "umbellatus"
        for _ in 1:2; for n in [7, 8]; rotate!(net_dc, n); end; end
    elseif clade == "odontosepalus_colombianid"
        for _ in 1:2; for n in [21, 22, 16, 17]; rotate!(net_dc, n); end; end
    end

    #make colors match previous Lagomarsino plots
    coltrait = trait == "fruit" ? ["red", "blue"] : ["deeppink", "chartreuse4"]
    #replace pollinator to pollinator syndrome for legend label
    if trait == "pollinator"
        trait == "pollinator syndrome"
    end

    #replace mispelled species & species that aren't really new but aren't id'ed
    label_map = Dict(
    "S_retorsus" => "S_retrorsus",
    "S_spnov3" => "S_sp. 3",
    "C_spnov3" => "C_sp. 3",
    "C_spnov4" => "C_sp. 4",
    "C_spnov5" => "C_sp. 5",
    "S_spnov1" => "S_sp. 1",
    )

    for leaf in tiplabels(net_dc)
        if haskey(label_map, leaf)
            leaf = label_map[leaf]
        end
    end

    #scale plot by number of tips
    ntips = length(tiplabels(net_dc))
    xpad, ypad = 2.0, 2.0
    xmax = ntips + xpad + 2.0  # extra space for legend
    ymax = ntips + ypad
    pdf_width = 0.5 * ntips + 4  # increase to accommodate legend
    pdf_height = 6

    #pie size scales with number of tips (smaller if more tips)
    pie_radius = clamp(4 / ntips, 0.12, 0.2)

    R"pdf"(figure_filename, height=pdf_height, width=pdf_width);
    # start the plot
    R"par"(mar=[0,0,0,0], cex=0.75);
    res = plot(net_dc, tipoffset=0.5, xlim=[0.5,xmax], ylim=[0,ymax], arrowlen=0.15,
            nodelabel = asr_dc[:,[:nodenumber, :fake]], showgamma=true);
    ndf = res[:node_data] # locations of internal nodes --> this is different depending on PhyloPlots version

    # add pie charts, using locations of internal nodes
    for i in 1:nrow(asr_dc) # loop over each row in the ancestral state reconstruction data frame
        ii = findfirst(isequal(string(asr_dc[!,:nodenumber][i])), ndf[!,:num]);
        colpp = Vector(asr_dc[i,colnames]);    
        R"ape::floating.pie.asp"(ndf[ii,:x], ndf[ii,:y], colpp,
                                radius=0.2, col=coltrait);
    end

    legend_x = 0.7
    legend_y = ymax - 1
    # add legend with correct mapping of color -> state
    R"legend"(x=legend_x, y=legend_y, legend=colnames, pch=21, var"pt.bg"=coltrait,
            bty="n", title=trait, var"title.adj"=0, var"pt.cex"=1.5);
    R"dev.off"();
end
```

```{julia}
for (key, value) in asr_results
    #remove the "_asr" first
    base = replace(key, "_asr" => "")

    #split from the right only once — gives (clade, trait)
    parts = rsplit(base, "_", limit=2)
    clade = parts[1]
    trait = parts[2]
    figure_filename = "output/netviz/" * clade * "_" * trait * ".pdf"

    if trait == "pollinator"
        legend = "pollinator syndrome"
    else legend = "fruit"
    end

    plot_discreteasr(value, figure_filename, clade_calibrated[clade], legend)
end
```