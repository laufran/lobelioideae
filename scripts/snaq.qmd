---
title: "snaq analyses"
output: github_document
date: 2024-7-3
---

```{julia}
using PhyloNetworks
using DataFrames
using CSV
using StaticArrays
using Plots
using PhyloPlots
```

Using our new dataset, we have 776 gene trees for many *Burmeistera*, *Siphocampylus*, *Centropogon* and outgroup (*Lobelia sp.*, *S. mannettiflorus*, *Lysipomia sp.*) species. To run SNaQ in tractable sizes (~20 taxa or less), we can take two approaches:
1. depth: sampling all individuals/species in each subclade, running a subclade at a time
2. breadth: randomly (with weight on well sampled) taking individuals from various subclades to get a "backbone"

fixit: update these numbers
Our clades we'll be running at a time for the first approach:
1. eucentropogonids: 17 individuals, 9 species
2. brevilimbatids: 15 individuals, 14 species
3. andinus: 11 individuals, 8 species
4. tupaeformis: 14 individuals, 12 species
5. giganteus grade + burmeisterids: 13 individuals, 8 species
    - giganteus: 6 individuals, 4 species
    - burmeisterids: 5 individuals, 4 species
6. odontosepalus + colombianids: 14 individuals, 11 species
    - colombianids: 6 individuals, 4 species
    - odontosepalus: 8 individuals, 7 species
7. correoides + nobilis subclades in scandens grade: 10 individuals, 9 species
    - correoides: 7 individuals, 6 species
    - nobilis: 3 individuals, 3 species
8. actinothrix subclade (scandens) + S. asplundii: 10 individuals, 10 species
    - actinothrix: 5 individuals, 5 species
    - S. asplundii: 1 individual, 1 species
9. peruvianids: 16 individuals, 10 species
10. umbellatus: 7 individuals, 5 species

    - furax: 4 individuals, 4 species

These clade / subclade names correspond to Lagomarsino et al. 2022. Clades that were grouped together were chosen based on their sister clade status / sizes. The peruvianids + umbellatus clade could potentially be grouped together if we do not include all individuals, and just choose a representative from each species.

to do: 

- decide on outgroup to include? different one for each clade? [X]
    - add to each group's labels [X]
- modify `countquartetsintrees` to give quartets for a subset of taxa, given labels [X]
    - debug pruning trees based on subset given [X]
- run SNaQ for each group h=0 to max of ??? [X]
    - change default arguments? time test? [X]

Has to be run all the time:
```{julia}
genetrees = readMultiTopology("data/newgts/all_singlecopy_orthologs_gene_trees.tre");

#filter Burmeistera from genetrees
tips = tipLabels(genetrees)
#use regex to get sample that start either "Bur_sp" or "Burmeistera_sp"
burmeistera = filter(contains(r"Bur_"), tips)
append!(burmeistera, filter(contains(r"Burmeistera_"), tips))
#remove outlier C. palmanus sample that's falling in wrong clade
push!(burmeistera, "Centro_palmanus_LL193_L1")
for gt in genetrees
    for tip in burmeistera
        try deleteleaf!(gt,tip) 
        catch e
        end
    end
end
```

Has to be run all the time:
Defines the subclades
```{julia}
samples = DataFrame(CSV.File("data/sampling_csvs/subclades.csv",stringtype=String)) #load df from CSV
#filter out sample from 2022 paper not included in the new gts
#filter out palmanus sample that falls in the wrong clade
filter!(:excluded2024 => excluded2024 -> excluded2024 == false, samples)
indls_to_sp = Dict{String, String}() #initialize
#get individuals from sample column
indls = unique(samples.sample)
#loop over every indl to add the indl -> species mapping to dict
for indl in indls
    df = filter(:sample => sample -> sample == indl, samples)
    indls_to_sp[indl]=only(df.simplename)
end

cladedict = Dict{String, Vector}() #initialize
#get vector of unique clade names
clades = unique(samples.clade2024)
#loop over every clade to make a dictionary of vectors
#where the vectors contain the species names that correspond to that clade
for clade in clades
    df = filter(:clade2024 => clade2024 -> clade2024 == clade, samples)
    cladedict[clade]=unique(df.simplename)
end

#do the same for subclades
subcladedict = Dict{String, Vector}() #initialize
subclades = unique(samples.subclade2024)
#skip over rows that don't have subclade identifier
subclades = collect(skipmissing(subclades))
for subclade in subclades
    df = dropmissing(samples, :subclade2024)
    filter!(:subclade2024 => subclade2024 -> subclade2024 == subclade, df)
    subcladedict[subclade]=unique(df.simplename)
end

eucentropogonid_labels = cladedict["eucentropogonid"]
peruvianid_labels = cladedict["peruvianid"]
#push!(peruvianid_labels, "S_smilax")

umbellatus_labels = cladedict["umbellatus"]
#push!(umbellatus_labels, "S_smilax")

andinus_labels = cladedict["andinus"]
#push!(andinus_labels, "S_smilax")
tupaeformis_labels = cladedict["tupaeformis"]

brevilimbatid_labels = cladedict["brevilimbatid"]

giganteus_burmeisterid_labels = cladedict["giganteus"]
append!(giganteus_burmeisterid_labels, cladedict["burmeisterid"])
#push!(giganteus_burmeisterid_labels, "S_smilax")

odontosepalus_colombianid_labels = cladedict["odontosepalus"]
append!(odontosepalus_colombianid_labels, cladedict["colombianid"])
push!(odontosepalus_colombianid_labels, "S_nematosepalus")
#push!(odontosepalus_colombianid_labels, "S_smilax")

correoides_nobilis_labels = subcladedict["correoides"]
append!(correoides_nobilis_labels, subcladedict["nobilis"])

actinothrix_labels = subcladedict["actinothrix"]
#append!(furax_actinothrix_labels, subcladedict["actinothrix"])
push!(actinothrix_labels, "S_asplundii")

subnetwork_groups = [eucentropogonid_labels, peruvianid_labels, umbellatus_labels,
                    andinus_labels, tupaeformis_labels, brevilimbatid_labels,
                    giganteus_burmeisterid_labels, odontosepalus_colombianid_labels,
                    correoides_nobilis_labels, actinothrix_labels]
subnetwork_names = ["eucentropogonid", "peruvianid", "umbellatus",
                    "andinus", "tupaeformis", "brevilimbatid",
                    "giganteus_burmeisterid", "odontosepalus_colombianid",
                    "correoides_nobilis", "actinothrix"]
#add outgroup to all clades - this is the outgroup sample with best gt presence %
for group in subnetwork_groups
    push!(group, "Lysipomia_pumila")
end
```

Should not be run all the time:
```{julia}
function countquartets_pruned(tree::Vector{HybridNetwork},
                           taxonmap::Dict{String,String},
                           taxlabels::Vector{String};
                           whichQ::Symbol=:all, weight_byallele::Bool=false,
                           showprogressbar::Bool=true)
    whichQ in [:all, :intrees, :labels] || error("whichQ must be either :all, :intrees, or :labels, but got $whichQ")
    if isempty(taxonmap)
        taxa = unionTaxa(tree)
    elseif whichQ == :labels
        #filter taxon map given taxlabels
        #fixit: add something about checking that all taxa are in the taxonmap
        filteredtaxonmap = filter(p -> p.second ∈ taxlabels, taxonmap)
        #filter gene trees given indl names in filteredtaxonmap
        #deep copy tree so we don't modify original file
        tree_copy = deepcopy(tree)
        #get all tip labels to delete
        tipstodelete = setdiff(collect(keys(taxonmap)), collect(keys(filteredtaxonmap)))
        #fixit: silence warnings on this?
        for gt in tree_copy
            for tip in tipstodelete
                try deleteleaf!(gt,tip) 
                catch e
                end
            end
        end
        tree = filter(gt -> gt.numTaxa > 4, tree_copy) #remove gene trees with less than 4 tips
        taxa = sort!(collect(Set(haskey(filteredtaxonmap, l.name) ? filteredtaxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
    else
        taxa = sort!(collect(Set(haskey(taxonmap, l.name) ? taxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
    end
    taxonnumber = Dict(taxa[i] => i for i in eachindex(taxa))
    ntax = length(taxa)
    nCk = PhyloNetworks.nchoose1234(ntax) # matrix used to ranks 4-taxon sets
    qtype = MVector{4,Float64} # 4 floats: CF12_34, CF13_24, CF14_23, ngenes; initialized at 0.0
    if (whichQ == :all || whichQ == :labels)
        numq = nCk[ntax+1,4]
        quartet = Vector{PhyloNetworks.QuartetT{qtype}}(undef, numq)
        ts = [1,2,3,4]
        for qi in 1:numq
            quartet[qi] = PhyloNetworks.QuartetT(qi, SVector{4}(ts), MVector(0.,0.,0.,0.))
            # next: find the 4-taxon set with the next rank,
            #       faster than using the direct mapping function
            ind = findfirst(x -> x>1, diff(ts))
            if ind === nothing ind = 4; end
            ts[ind] += 1
            for j in 1:(ind-1)
                ts[j] = j
            end
        end
    elseif whichQ == :intrees
        error("whichQ = :intrees not implemented yet")
        # fixit: read all the trees, go through each edge, check if the current quartet list covers the edge, if not: add a quartet
    end
    totalt = length(tree)
    if showprogressbar
        nstars = (totalt < 50 ? totalt : 50)
        ntrees_perstar = (totalt/nstars)
        println("Reading in trees, looking at $numq quartets in each...")
        print("0+" * "-"^nstars * "+100%\n  ")
        stars = 0
        nextstar = Integer(ceil(ntrees_perstar))
    end  
    for i in 1:totalt # number of times each quartet resolution is seen in each tree
        PhyloNetworks.countquartetsintrees!(quartet, tree[i], whichQ, weight_byallele, nCk, taxonnumber, taxonmap)
        if showprogressbar && i >= nextstar
            print("*")
            stars += 1
            nextstar = Integer(ceil((stars+1) * ntrees_perstar))
        end
    end
    showprogressbar && print("\n")
    # normalize counts to frequencies & number of genes
    for q in quartet
        d = q.data
        d[4] = d[1]+d[2]+d[3] # number of genes
        if d[4] > 0.0
            d[1:3] /= d[4]
        end # otherwise: no genes with data on this quartet (missing taxa or polytomy): leave all zeros (NaN if /0)
    end
    return quartet, taxa
end

#loop over all subnetwork groups to calc CF tables and write to csvs
idx = 1
for group in subnetwork_groups
    q,t = countquartets_pruned(genetrees, indls_to_sp, group, whichQ= :labels)
    df = writeTableCF(q,t)
    cladenames = split(subnetwork_names[idx], "_labels")[1]
    CSV.write("data/cfs/$cladenames-tableCF.csv", df);
    idx += 1
end
```

```{julia}
function run_snaq_on_subclade(clade, h, sptree, subnetwork_groups, subnetwork_names)
    label = split(clade,"-")[1] #get label from CSV name
    group_num = findfirst(==(label), subnetwork_names)
    group = subnetwork_groups[group_num]
    #subnetwork_names is parallel to subnetwork_groups
    #with values being the clade label, so access the labels through the index of the label

    #make deepcopy
    cladetree = deepcopy(sptree)
    #filter taxon map to only include species from our focal clade
    filteredtaxonmap = filter(p -> p.second ∈ group, indls_to_sp)
    #get the kets from our filtered dict- should be sample/indl names, not species names
    filteredsamplenames = collect(keys(filteredtaxonmap))
    #get vector of sample names to delete- those from other clades
    tipstodelete = setdiff(collect(keys(indls_to_sp)), filteredsamplenames)
    #and all the Burmeistera sp.
    append!(tipstodelete, burmeistera)

    #prune all indls from other groups
    for tip in tipstodelete
        deleteleaf!(cladetree,tip) 
    end    

    cladestring = split(subnetwork_names[group_num], "_labels")[1]
    #remove tips with multiple samples in focal clade
    #if length of species is unequal to length of individuals
    if length(group) != length(filteredsamplenames)
        #if there are multiple clades, split the string
        #and get a vector of the multiple clades
        if contains(cladestring, "_")
            cladenames = split(cladestring, "_")
        #else, make vector of just the single string to iterate on
        else cladenames = [cladestring] 
        end
        for clade in cladenames
            #filter samples df for just indls within our focal clade
            df = filter(:clade2024 => clade2024 -> clade2024 == clade, samples)
            sort!(df, :gts, rev=true) #sort in descending order of gt presence %
            #identify dupe indls to remove (those that occur second or more after 
            #first occurrence - indl of same species with best gt presence %)
            extraindls = df[nonunique(df, :species, keep=:first), :].sample
            #remove extra indls
            for indl in extraindls
                deleteleaf!(cladetree, indl)
            end
        end
    end

    #rename sp. tree edges to match names in CF table
    for n in cladetree.node
        isleaf(n) && (n.name = filteredtaxonmap[n.name])
    end

    #read in CF table for clade
    cftable = readTableCF(DataFrame(CSV.File("data/cfs/$clade"); copycols=false))
            
    #randomize and log seed
    rand_seed = rand(1000:9999)
    row = DataFrame(clade = ["$cladestring"], h = ["$h"], seed = ["$rand_seed"])
    CSV.write("output/snaq/seed_logs.csv", row, append = true)
    snaq!(cladetree, cftable, hmax=h, runs=30, filename="output/snaq/$cladestring-hmax$h", seed=rand_seed)

end
```

This block should be run on a cluster to use multiprocessing:
fixit: deal with blocks above and using .jl script

```{julia}
vals = [0, 1, 2, 3]
filenames = readdir("data/cfs")
filenames = ["brevilimbatid-tableCF.csv", "odontosepalus_colombianid-tableCF.csv", "correoides_nobilis-tableCF.csv"]
sptree = readTopology("data/newgts/species_tree_newick.tre")

clades_h_list = collect((clade,h)
    for h in 0:3
    for clade in filenames)

@sync @distributed for (clade, h) in clades_h_list
    cladeName = split(clade,"-")[1]  
    if isfile("output/snaq/$cladeName-hmax$h.out")
        println("SNAQ for $cladeName, h = $h already present. Skipping")
        continue
    else
        println("Running SNAQ for $cladeName, h = $h")
        run_snaq_on_subclade(clade, h, sptree, subnetwork_groups, subnetwork_names)
    end
end
```

fixit: probably delete everything above since it's in snaq_setup
----

## Look at snaq results for all subclades

Get nets and scores from logs, store in a dict:
```{julia}
vals = [0, 1, 2, 3]
subclade_scores_nosmilax = Dict{String, Vector}()

for clade in subnetwork_names
    clade_scores = []
    clade_nets = []

    for h in vals
        #open file, get first line
        filename = "output/snaq-withoutsmilax/$clade-hmax$h.out"
        open(filename) do f
            #first line in log has best scored net/tree
            firstline = readlines(f)[1]
            splitfirst = split(firstline, " -Ploglik = ")
            net = readTopology(splitfirst[1])
            push!(clade_nets, net)
            score = parse(Float64, splitfirst[2])
            push!(clade_scores, score)
        end
    end

    subclade_scores_nosmilax[clade] = [clade_scores, clade_nets]
end
```

generate plot of hvals:
```{julia}
for (k,v) in subclade_scores_nosmilax
    #fixit: add title with subclade name (k)
    #fixit: add labels for x and y axis
    Plots.plot(collect(0:3), v[1])
    savefig("output/hvals-withoutsmilax/$k-hvals.pdf")
end
```

```{julia}
supported_nets_nosmilax = []

nets_to_hvals_nosmilax = Dict("actinothrix" => 1, 
                            "andinus" => 1, 
                            "brevilimbatid" => 2,
                            "correoides_nobilis" => 2,
                            "eucentropogonid" => 1,
                            "tupaeformis" => 1,
                            "umbellatus" => 2,
                            "peruvianid" => 1, #conflicts with root
                            "giganteus_burmeisterid" => 1,
                            "odontosepalus_colombianid" => 2)

function getsupportednet(clade::AbstractString, hvalmappingdict::Dict, cladescores::Dict)
    hval_index = hvalmappingdict[clade] + 1
    cladescores[clade][2][hval_index]
end

for clade in subnetwork_names
    net_sym = Symbol(clade * "_net")
    @eval begin
        $net_sym = getsupportednet($clade, nets_to_hvals_nosmilax, subclade_scores_nosmilax)
        push!(supported_nets_nosmilax, $net_sym)
    end
end

for net in supported_nets_nosmilax
  try
    rootatnode!(net, "Lysipomia_pumila")
  catch e
  end
end
```

fixit: automate visualization of nets and writing out pdf
```{julia}
```

## Look at subclades that smilax may be involved with

```{julia}
subclade_scores_smilax = Dict{String, Vector}()

for clade in ["andinus", "giganteus_burmeisterid", "odontosepalus_colombianid", "peruvianid", "umbellatus"]
    clade_scores = []
    clade_nets = []

    for h in vals
        #open file, get first line
        filename = "output/snaq-withsmilax/$clade-hmax$h.out"
        open(filename) do f
            #first line in log has best scored net/tree
            firstline = readlines(f)[1]
            splitfirst = split(firstline, " -Ploglik = ")
            net = readTopology(splitfirst[1])
            push!(clade_nets, net)
            score = parse(Float64, splitfirst[2])
            push!(clade_scores, score)
        end
    end

    subclade_scores_smilax[clade] = [clade_scores, clade_nets]
end
```

visualize hvals:
```{julia}
for (k,v) in subclade_scores_smilax
    #add title with subclade name (k)
    #add labels for x and y axis
    Plots.plot(collect(0:3), v[1])
    savefig("output/hvals-withsmilax/$k-hvals.pdf")
end
```

```{julia}
supported_nets_smilax = []

nets_to_hvals_smilax = Dict("peruvianid" => 1,
                            "giganteus_burmeisterid" => 1,
                            "odontosepalus_colombianid" => 2,
                            "umbellatus" => 1,
                            "andinus" => 1)


getsupportednet("odontosepalus_colombianid", nets_to_hvals_smilax, subclade_scores_smilax)

for clade in ["andinus", "giganteus_burmeisterid", "odontosepalus_colombianid", "peruvianid", "umbellatus"]
    net_sym = Symbol(clade * "_net_smilax")
    @eval begin
        $net_sym = getsupportednet($clade, nets_to_hvals_smilax, subclade_scores_smilax)
        push!(supported_nets_smilax, $net_sym)
    end
end

for net in supported_nets_smilax
  try
    rootatnode!(net, "Lysipomia_pumila")
  catch e
  end
end
```

results:
    - andinus: doesn't involve smilax, same topology as before. --> keep old topology.
    - umbellatus: doesn't involve smilax, same topology as before. --> keep old topology.
    ----
    - peruvianid: h=1 involves ghost, but not root, nor smilax.
    - odontosepalus: h=2 doesn't involve smilax directly, but finds smilax sister to nematosepalus.
    - giganteus: involves smilax.