---
title: "snaq analyses"
output: github_document
date: 2024-7-3
---

```{julia}
using PhyloNetworks
using DataFrames
using CSV
using StaticArrays
genetrees = readMultiTopology("data/newgts/all_singlecopy_orthologs_gene_trees.tre");
```

Using our new dataset, we have 776 gene trees for many *Burmeistera*, *Siphocampylus*, *Centropogon* and outgroup (*Lobelia sp.*, *S. mannettiflorus*, *Lysipomia sp.*) species. To run SNaQ in tractable sizes (~20 taxa or less), we can take two approaches:
1. depth: sampling all individuals/species in each subclade, running a subclade at a time
2. breadth: randomly (with weight on well sampled) taking individuals from various subclades to get a "backbone"

Our clades we'll be running at a time for the first approach:
1. eucentropogonids: 17 individuals, 10 species
2. brevilimbatids + S. nematosepalus: 17 individuals, 16 species
3. andinus: 11 individuals, 8 species
4. tupaeformis: 14 individuals, 12 species
5. giganteus grade + burmeisterids: 13 individuals, 8 species
6. odontosepalus + colombianids + S. corymbifer, S. tessmannii, S. smilax: 17 individuals, 15 species
7. correoides + nobilis subclades in scandens grade: 10 individuals, 9 species
8. furax + actinothrix subclade (scandens) + S. asplundii: 10 individuals, 10 species
9. peruvianids: 16 individuals, 10 species
10. umbellatus: 7 individuals, 5 species

These clade / subclade names correspond to Lagomarsino et al. 2022. Clades that were grouped together were chosen based on their sister clade status / sizes. The peruvianids + umbellatus clade could potentially be grouped together if we do not include all individuals, and just choose a representative from each species.

to do: 

- modify `countquartetsintrees` to give quartets for a subset of taxa, given labels [X]
- run SNaQ for each group h=0 to max of ??? []
    - change default arguments? time test? []
- graft subnetworks to backbone (see google groups convo w Rowan Schley) []

```{julia}
samples = DataFrame(CSV.File("samples2024.csv",stringtype=String))
filter!(:excluded2024 => excluded2024 -> excluded2024 == false, samples)
indls_to_sp = Dict{String, String}()
indls = unique(samples.sample)
for indl in indls
    df = filter(:sample => sample -> sample == indl, samples)
    indls_to_sp[indl]=only(df.simplename)
end

cladedict = Dict{String, Vector}()
clades = unique(samples.clade2024)
for clade in clades
    df = filter(:clade2024 => clade2024 -> clade2024 == clade, samples)
    cladedict[clade]=unique(df.simplename)
end

subcladedict = Dict{String, Vector}()
subclades = unique(samples.subclade2024)
subclades = collect(skipmissing(subclades))
for subclade in subclades
    df = dropmissing(samples, :subclade2024)
    filter!(:subclade2024 => subclade2024 -> subclade2024 == subclade, df)
    subcladedict[subclade]=unique(df.simplename)
end

eucentropogonid_labels = cladedict["eucentropogonid"]
peruvianid_labels = cladedict["peruvianid"]
umbellatus_labels = cladedict["umbellatus"]
andinus_labels = cladedict["andinus"]
tupaeformis_labels = cladedict["tupaeformis"]

brevilimbatid_labels = cladedict["brevilimbatid"]
push!(brevilimbatid_labels, "S_nematosepalus")

giganteus_burmeisterid_labels = cladedict["giganteus"]
append!(giganteus_burmeisterid_labels, cladedict["burmeisterid"])

odontosepalus_colombianid_labels = cladedict["odontosepalus"]
append!(odontosepalus_colombianid_labels, cladedict["colombianid"])
push!(odontosepalus_colombianid_labels, "S_corymbifer")
push!(odontosepalus_colombianid_labels, "C_tessmannii")
push!(odontosepalus_colombianid_labels, "S_smilax")

correoides_nobilis_labels = subcladedict["correoides"]
append!(correoides_nobilis_labels, subcladedict["nobilis"])

furax_actinothrix_labels = cladedict["furax"]
append!(furax_actinothrix_labels, subcladedict["actinothrix"])
push!(furax_actinothrix_labels, "S_asplundii")
```

```{julia}
function countquartets_pruned(tree::Vector{HybridNetwork},
                           taxonmap::Dict{String,String},
                           taxlabels::Vector{String};
                           whichQ::Symbol=:all, weight_byallele::Bool=false,
                           showprogressbar::Bool=true)
    whichQ in [:all, :intrees, :labels] || error("whichQ must be either :all, :intrees, or :labels, but got $whichQ")
    if isempty(taxonmap)
        taxa = unionTaxa(tree)
    elseif whichQ == :labels
        #filter taxon map given taxlabels
        filteredtaxonmap = filter(p -> p.second âˆˆ taxlabels, taxonmap)
        taxa = sort!(collect(Set(haskey(filteredtaxonmap, l.name) ? filteredtaxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
        #fixit: filter gene trees given taxlabels/taxonmap
    else
        taxa = sort!(collect(Set(haskey(taxonmap, l.name) ? taxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
    end
    taxonnumber = Dict(taxa[i] => i for i in eachindex(taxa))
    ntax = length(taxa)
    nCk = PhyloNetworks.nchoose1234(ntax) # matrix used to ranks 4-taxon sets
    qtype = MVector{4,Float64} # 4 floats: CF12_34, CF13_24, CF14_23, ngenes; initialized at 0.0
    if (whichQ == :all || whichQ == :labels)
        numq = nCk[ntax+1,4]
        quartet = Vector{PhyloNetworks.QuartetT{qtype}}(undef, numq)
        ts = [1,2,3,4]
        for qi in 1:numq
            quartet[qi] = PhyloNetworks.QuartetT(qi, SVector{4}(ts), MVector(0.,0.,0.,0.))
            # next: find the 4-taxon set with the next rank,
            #       faster than using the direct mapping function
            ind = findfirst(x -> x>1, diff(ts))
            if ind === nothing ind = 4; end
            ts[ind] += 1
            for j in 1:(ind-1)
                ts[j] = j
            end
        end
    elseif whichQ == :intrees
        error("whichQ = :intrees not implemented yet")
        # fixit: read all the trees, go through each edge, check if the current quartet list covers the edge, if not: add a quartet
    end
    totalt = length(tree)
    if showprogressbar
        nstars = (totalt < 50 ? totalt : 50)
        ntrees_perstar = (totalt/nstars)
        println("Reading in trees, looking at $numq quartets in each...")
        print("0+" * "-"^nstars * "+100%\n  ")
        stars = 0
        nextstar = Integer(ceil(ntrees_perstar))
    end
    for i in 1:totalt # number of times each quartet resolution is seen in each tree
        PhyloNetworks.countquartetsintrees!(quartet, tree[i], whichQ, weight_byallele, nCk, taxonnumber, taxonmap)
        if showprogressbar && i >= nextstar
            print("*")
            stars += 1
            nextstar = Integer(ceil((stars+1) * ntrees_perstar))
        end
    end
    showprogressbar && print("\n")
    # normalize counts to frequencies & number of genes
    for q in quartet
        d = q.data
        d[4] = d[1]+d[2]+d[3] # number of genes
        if d[4] > 0.0
            d[1:3] /= d[4]
        end # otherwise: no genes with data on this quartet (missing taxa or polytomy): leave all zeros (NaN if /0)
    end
    return quartet, taxa
end

countquartets_pruned(genetrees, indls_to_sp, eucentropogonid_labels, whichQ= :labels)
```