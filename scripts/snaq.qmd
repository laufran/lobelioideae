---
title: "snaq analyses"
output: github_document
date: 2024-7-3
---

```{julia}
using PhyloNetworks
using DataFrames
using CSV
using StaticArrays
```

Using our new dataset, we have 776 gene trees for many *Burmeistera*, *Siphocampylus*, *Centropogon* and outgroup (*Lobelia sp.*, *S. mannettiflorus*, *Lysipomia sp.*) species. To run SNaQ in tractable sizes (~20 taxa or less), we can take two approaches:
1. depth: sampling all individuals/species in each subclade, running a subclade at a time
2. breadth: randomly (with weight on well sampled) taking individuals from various subclades to get a "backbone"

Our clades we'll be running at a time for the first approach:
1. eucentropogonids: 17 individuals, 9 species
2. brevilimbatids: 15 individuals, 14 species
3. andinus: 11 individuals, 8 species
4. tupaeformis: 14 individuals, 12 species
5. giganteus grade + burmeisterids: 13 individuals, 8 species
    - giganteus: 6 individuals, 4 species
    - burmeisterids: 5 individuals, 4 species
6. odontosepalus + colombianids: 14 individuals, 11 species
    - colombianids: 6 individuals, 4 species
    - odontosepalus: 8 individuals, 7 species
7. correoides + nobilis subclades in scandens grade: 10 individuals, 9 species
    - correoides: 7 individuals, 6 species
    - nobilis: 3 individuals, 3 species
8. furax + actinothrix subclade (scandens) + S. asplundii: 10 individuals, 10 species
    - furax: 4 individuals, 4 species
    - actinothrix: 5 individuals, 5 species
9. peruvianids: 16 individuals, 10 species
10. umbellatus: 7 individuals, 5 species

These clade / subclade names correspond to Lagomarsino et al. 2022. Clades that were grouped together were chosen based on their sister clade status / sizes. The peruvianids + umbellatus clade could potentially be grouped together if we do not include all individuals, and just choose a representative from each species.

to do: 

- decide on outgroup to include? different one for each clade? [X]
    - add to each group's labels [X]
- modify `countquartetsintrees` to give quartets for a subset of taxa, given labels [X]
    - debug pruning trees based on subset given [X]
- run SNaQ for each group h=0 to max of ??? []
    - change default arguments? time test? []
- graft subnetworks to backbone (see google groups convo w Rowan Schley) []
    - decide what species to include along backbone (rogue ones)

```{julia}
genetrees = readMultiTopology("data/newgts/all_singlecopy_orthologs_gene_trees.tre");

#filter Burmeistera from genetrees
tips = tipLabels(genetrees)
#use regex to get sample that start either "Bur_sp" or "Burmeistera_sp"
burmeistera = filter(contains(r"Bur_"), tips)
append!(burmeistera, filter(contains(r"Burmeistera_"), tips))
#remove outlier C. palmanus sample that's falling in wrong clade
push!(burmeistera, "Centro_palmanus_LL193_L1")
for gt in genetrees
    for tip in burmeistera
        try deleteleaf!(gt,tip) 
        catch e
        end
    end
end
```

```{julia}
samples = DataFrame(CSV.File("data/sampling_csvs/subclades.csv",stringtype=String)) #load df from CSV
#filter out sample from 2022 paper not included in the new gts
filter!(:excluded2024 => excluded2024 -> excluded2024 == false, samples)
indls_to_sp = Dict{String, String}() #initialize
#get individuals from sample column
indls = unique(samples.sample)
#loop over every indl to add the indl -> species mapping to dict
for indl in indls
    df = filter(:sample => sample -> sample == indl, samples)
    indls_to_sp[indl]=only(df.simplename)
end

cladedict = Dict{String, Vector}() #initialize
#get vector of unique clade names
clades = unique(samples.clade2024)
#loop over every clade to make a dictionary of vectors
#where the vectors contain the species names that correspond to that clade
for clade in clades
    df = filter(:clade2024 => clade2024 -> clade2024 == clade, samples)
    cladedict[clade]=unique(df.simplename)
end

#do the same for subclades
subcladedict = Dict{String, Vector}() #initialize
subclades = unique(samples.subclade2024)
#skip over rows that don't have subclade identifier
subclades = collect(skipmissing(subclades))
for subclade in subclades
    df = dropmissing(samples, :subclade2024)
    filter!(:subclade2024 => subclade2024 -> subclade2024 == subclade, df)
    subcladedict[subclade]=unique(df.simplename)
end

eucentropogonid_labels = cladedict["eucentropogonid"]
peruvianid_labels = cladedict["peruvianid"]
umbellatus_labels = cladedict["umbellatus"]
andinus_labels = cladedict["andinus"]
tupaeformis_labels = cladedict["tupaeformis"]

brevilimbatid_labels = cladedict["brevilimbatid"]

giganteus_burmeisterid_labels = cladedict["giganteus"]
append!(giganteus_burmeisterid_labels, cladedict["burmeisterid"])

odontosepalus_colombianid_labels = cladedict["odontosepalus"]
append!(odontosepalus_colombianid_labels, cladedict["colombianid"])

correoides_nobilis_labels = subcladedict["correoides"]
append!(correoides_nobilis_labels, subcladedict["nobilis"])

furax_actinothrix_labels = cladedict["furax"]
append!(furax_actinothrix_labels, subcladedict["actinothrix"])
push!(furax_actinothrix_labels, "S_asplundii")

subnetwork_groups = [eucentropogonid_labels, peruvianid_labels, umbellatus_labels,
                    andinus_labels, tupaeformis_labels, brevilimbatid_labels,
                    giganteus_burmeisterid_labels, odontosepalus_colombianid_labels,
                    correoides_nobilis_labels, furax_actinothrix_labels]
subnetwork_names = ["eucentropogonid", "peruvianid", "umbellatus",
                    "andinus", "tupaeformis", "brevilimbatid",
                    "giganteus_burmeisterid", "odontosepalus_colombianid",
                    "correoides_nobilis", "furax_actinothrix"]
#add outgroup to all clades - this is the outgroup sample with best gt presence %
for group in subnetwork_groups
    push!(group, "LL104_Lysipomia")
end
```

```{julia}
function countquartets_pruned(tree::Vector{HybridNetwork},
                           taxonmap::Dict{String,String},
                           taxlabels::Vector{String};
                           whichQ::Symbol=:all, weight_byallele::Bool=false,
                           showprogressbar::Bool=true)
    whichQ in [:all, :intrees, :labels] || error("whichQ must be either :all, :intrees, or :labels, but got $whichQ")
    if isempty(taxonmap)
        taxa = unionTaxa(tree)
    elseif whichQ == :labels
        #filter taxon map given taxlabels
        #fixit: add something about checking that all taxa are in the taxonmap
        filteredtaxonmap = filter(p -> p.second âˆˆ taxlabels, taxonmap)
        #filter gene trees given indl names in filteredtaxonmap
        #deep copy tree so we don't modify original file
        tree_copy = deepcopy(tree)
        #get all tip labels to delete
        tipstodelete = setdiff(collect(keys(taxonmap)), collect(keys(filteredtaxonmap)))
        #fixit: silence warnings on this?
        for gt in tree_copy
            for tip in tipstodelete
                try deleteleaf!(gt,tip) 
                catch e
                end
            end
        end
        tree = filter(gt -> gt.numTaxa > 4, tree_copy) #remove gene trees with less than 4 tips
        taxa = sort!(collect(Set(haskey(filteredtaxonmap, l.name) ? filteredtaxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
    else
        taxa = sort!(collect(Set(haskey(taxonmap, l.name) ? taxonmap[l.name] : l.name
                                 for t in tree for l in t.leaf)))
    end
    taxonnumber = Dict(taxa[i] => i for i in eachindex(taxa))
    ntax = length(taxa)
    nCk = PhyloNetworks.nchoose1234(ntax) # matrix used to ranks 4-taxon sets
    qtype = MVector{4,Float64} # 4 floats: CF12_34, CF13_24, CF14_23, ngenes; initialized at 0.0
    if (whichQ == :all || whichQ == :labels)
        numq = nCk[ntax+1,4]
        quartet = Vector{PhyloNetworks.QuartetT{qtype}}(undef, numq)
        ts = [1,2,3,4]
        for qi in 1:numq
            quartet[qi] = PhyloNetworks.QuartetT(qi, SVector{4}(ts), MVector(0.,0.,0.,0.))
            # next: find the 4-taxon set with the next rank,
            #       faster than using the direct mapping function
            ind = findfirst(x -> x>1, diff(ts))
            if ind === nothing ind = 4; end
            ts[ind] += 1
            for j in 1:(ind-1)
                ts[j] = j
            end
        end
    elseif whichQ == :intrees
        error("whichQ = :intrees not implemented yet")
        # fixit: read all the trees, go through each edge, check if the current quartet list covers the edge, if not: add a quartet
    end
    totalt = length(tree)
    if showprogressbar
        nstars = (totalt < 50 ? totalt : 50)
        ntrees_perstar = (totalt/nstars)
        println("Reading in trees, looking at $numq quartets in each...")
        print("0+" * "-"^nstars * "+100%\n  ")
        stars = 0
        nextstar = Integer(ceil(ntrees_perstar))
    end
    for i in 1:totalt # number of times each quartet resolution is seen in each tree
        PhyloNetworks.countquartetsintrees!(quartet, tree[i], whichQ, weight_byallele, nCk, taxonnumber, taxonmap)
        if showprogressbar && i >= nextstar
            print("*")
            stars += 1
            nextstar = Integer(ceil((stars+1) * ntrees_perstar))
        end
    end
    showprogressbar && print("\n")
    # normalize counts to frequencies & number of genes
    for q in quartet
        d = q.data
        d[4] = d[1]+d[2]+d[3] # number of genes
        if d[4] > 0.0
            d[1:3] /= d[4]
        end # otherwise: no genes with data on this quartet (missing taxa or polytomy): leave all zeros (NaN if /0)
    end
    return quartet, taxa
end

#loop over all subnetwork groups to calc CF tables and write to csvs
idx = 1
for group in subnetwork_groups
    q,t = countquartets_pruned(genetrees, indls_to_sp, group, whichQ= :labels)
    df = writeTableCF(q,t)
    cladenames = split(subnetwork_names[idx], "_labels")[1]
    CSV.write("data/cfs/$cladenames-tableCF.csv", df);
    idx += 1
end
```

```{julia}
#prune species tree down to each group
sptree = readTopology("data/newgts/species_tree_newick.tre")

idx = 1
for group in subnetwork_groups
    #make deepcopy
    cladetree = deepcopy(sptree)
    #filter taxon map to only include species from our focal clade
    filteredtaxonmap = filter(p -> p.second âˆˆ group, indls_to_sp)
    #get the kets from our filtered dict- should be sample/indl names, not species names
    filteredsamplenames = collect(keys(filteredtaxonmap))
    #get vector of sample names to delete- those from other clades
    tipstodelete = setdiff(collect(keys(indls_to_sp)), filteredsamplenames)
    #and all the Burmeistera sp.
    append!(tipstodelete, burmeistera)

    #prune all indls from other groups
    for tip in tipstodelete
        deleteleaf!(cladetree,tip) 
    end    

    cladestring = split(subnetwork_names[idx], "_labels")[1]
    #remove tips with multiple samples in focal clade
    #if length of species is unequal to length of individuals
    if length(group) != length(filteredsamplenames)
        #if there are multiple clades, split the string
        #and get a vector of the multiple clades
        if contains(cladestring, "_")
            cladenames = split(cladestring, "_")
        #else, make vector of just the single string to iterate on
        else cladenames = [cladestring] 
        end
        for clade in cladenames
            #filter samples df for just indls within our focal clade
            df = filter(:clade2024 => clade2024 -> clade2024 == clade, samples)
            sort!(df, :gts, rev=true) #sort in descending order of gt presence %
            #identify dupe indls to remove (those that occur second or more after 
            #first occurrence - indl of same species with best gt presence %)
            extraindls = df[nonunique(df, :species, keep=:first), :].sample
            #remove extra indls
            for indl in extraindls
                deleteleaf!(cladetree, indl)
            end
        end
    end

    #rename sp. tree edges to match names in CF table
    for n in cladetree.node
        isleaf(n) && (n.name = filteredtaxonmap[n.name])
    end

    #read in CF table
    cftable = readTableCF(DataFrame(CSV.File("data/cfs/$cladestring-tableCF.csv"); copycols=false))

    #fixit: give different starting seed each time, log it
    #fixit: add time check
    snaq!(cladetree, cftable, hmax=0, runs=30, filename="output/snaq/$cladestring-net0", seed=1234)
    idx += 1
end
```